--- dahdi-linux-2.1.0.4/drivers/dahdi/wctc4xxp/base.c.orig
+++ dahdi-linux-2.1.0.4/drivers/dahdi/wctc4xxp/base.c
@@ -503,6 +503,25 @@
 
 };
 
+#ifdef HAVE_NETDEV_PRIV
+struct wcdte_netdev_priv {
+	struct wcdte *wc;
+};
+#endif
+
+static inline struct wcdte *
+wcdte_from_netdev(struct net_device *netdev)
+{
+#ifdef HAVE_NETDEV_PRIV
+	struct wcdte_netdev_priv *priv;
+	priv = netdev_priv(netdev);
+	return priv->wc;
+#else
+	return netdev->priv;
+#endif
+}
+
+
 static inline void wctc4xxp_set_ready(struct wcdte *wc) {
 	set_bit(DTE_READY, &wc->flags);
 }
@@ -568,7 +587,6 @@
 	return pt;
 }
 
-
 static struct sk_buff * 
 tcb_to_skb(struct net_device *netdev, const struct tcb *cmd)
 {
@@ -618,7 +636,7 @@
 static void 
 wctc4xxp_net_set_multi(struct net_device *netdev)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	DTE_DEBUG(DTE_DEBUG_GENERAL, "%s promiscuity:%d\n", 
 	   __FUNCTION__, netdev->promiscuity);
 }
@@ -626,7 +644,7 @@
 static int 
 wctc4xxp_net_up(struct net_device *netdev)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	DTE_DEBUG(DTE_DEBUG_GENERAL, "%s\n", __FUNCTION__);
 #if 1
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
@@ -641,7 +659,7 @@
 static int 
 wctc4xxp_net_down(struct net_device *netdev)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	DTE_DEBUG(DTE_DEBUG_GENERAL, "%s\n", __FUNCTION__);
 #if 1
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
@@ -658,7 +676,7 @@
 static int 
 wctc4xxp_net_hard_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	struct tcb *cmd;
 
 	/* We set DO_NOT_CAPTURE because this packet was already captured by
@@ -693,7 +711,7 @@
 static int 
 wctc4xxp_poll(struct net_device *netdev, int *budget)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	int count = 0;
 	int quota = min(netdev->quota, *budget);
 
@@ -719,7 +737,11 @@
 	count = wctc4xxp_net_receive(wc, budget);
 
 	if (!skb_queue_len(&wc->captured_packets)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
 		netif_rx_complete(wc->netdev, &wc->napi);
+#else
+		netif_rx_complete(&wc->napi);
+#endif
 	}
 	return count;
 }
@@ -728,7 +750,7 @@
 static struct net_device_stats *
 wctc4xxp_net_get_stats(struct net_device *netdev)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	return &wc->net_stats;
 }
 
@@ -765,7 +787,7 @@
 static int 
 wctc4xxp_net_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
 {
-	struct wcdte *wc = netdev->priv;
+	struct wcdte *wc = wcdte_from_netdev(netdev);
 	switch(cmd) {
 	case 0x89f0:
 		down(&wc->chansem);
@@ -794,14 +816,25 @@
 {
 	int res;
 	struct net_device *netdev;
+#	ifdef HAVE_NETDEV_PRIV
+	struct wcdte_netdev_priv *priv;
+#endif
 	const char our_mac[] = { 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
 
-	if (!(netdev = alloc_netdev(0, wc->board_name, ether_setup))) {
+#	ifdef HAVE_NETDEV_PRIV
+	netdev = alloc_netdev(sizeof(struct wcdte_netdev_priv *),
+			wc->board_name, ether_setup);
+	if (!netdev)
 		return -ENOMEM;
-	}
-
+	priv = netdev_priv(netdev);
+	priv->wc = wc;
+#	else
+	netdev = alloc_netdev(0, wc->board_name, ether_setup);
+	if (!netdev)
+		return -ENOMEM;
+	netdev->priv = wc;
+#	endif
 	memcpy(netdev->dev_addr, our_mac, sizeof(our_mac));
-	netdev->priv = wc;
 	netdev->set_multicast_list = &wctc4xxp_net_set_multi;
 	netdev->open = &wctc4xxp_net_up;
 	netdev->stop = &wctc4xxp_net_down;
@@ -890,10 +923,12 @@
 	}
 
 	skb_queue_tail(&wc->captured_packets, skb);
-#	if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#	if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 	netif_rx_schedule(netdev);
+#	elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	netif_rx_schedule(netdev, &wc->napi);
 #	else
-	netif_rx_schedule(netdev, &wc->napi);
+	netif_rx_schedule(&wc->napi);
 #	endif
 	return;
 }
