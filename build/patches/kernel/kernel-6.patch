--- sys/kern/vfs_mount.c.orig	Tue Oct 24 17:02:39 2006
+++ sys/kern/vfs_mount.c	Sat Dec  9 16:35:45 2006
@@ -1541,7 +1541,7 @@
 		strcpy(path, ROOTNAME);
 
 	error = kernel_vmount(
-	    MNT_RDONLY | MNT_ROOTFS,
+	    MNT_ROOTFS,
 	    "fstype", vfsname,
 	    "fspath", "/",
 	    "from", path,
--- sys/i386/i386/vm_machdep.c.orig	Sat Dec  9 14:05:24 2006
+++ sys/i386/i386/vm_machdep.c	Sat Aug 18 15:10:27 2007
@@ -600,6 +600,12 @@
 		outl(0xcfc, 0xf);
 	}

+	if (strcmp(cpu_vendor, "AuthenticAMD") == 0 &&
+	    (cpu_id & 0xfff0) == 0x05a0) {
+		/* PC Engines ALIX reset via CS5536 DIVIL_SOFT_RESET */
+		wrmsr(0x51400017, 1LL);
+	}
+
 #ifdef PC98
 	/*
 	 * Attempt to do a CPU reset via CPU reset port.
--- sys/i386/pci/pci_pir.c.orig	Mon Jul 18 21:45:21 2005
+++ sys/i386/pci/pci_pir.c	Tue Jan 15 19:23:59 2008
@@ -405,12 +405,6 @@
 		pci_pir_dump_links();
 	}

-	/* Check for unique IRQ masks. */
-	TAILQ_FOREACH(pci_link, &pci_links, pl_links) {
-		if (pci_link->pl_irqmask != 0 && powerof2(pci_link->pl_irqmask))
-			pci_link->pl_irq = ffs(pci_link->pl_irqmask) - 1;
-	}
-
 	/*
 	 * Check to see if the BIOS has already routed any of the links by
 	 * checking each device connected to each link to see if it has a
@@ -523,15 +517,20 @@
 	}

 	/*
-	 * Pick a new interrupt if we don't have one already.  We look for
-	 * an interrupt from several different sets.  First, we check the
-	 * set of PCI only interrupts from the $PIR.  Second, we check the
-	 * set of known-good interrupts that the BIOS has already used.
-	 * Lastly, we check the "all possible valid IRQs" set.
+	 * Pick a new interrupt if we don't have one already.  We look
+	 * for an interrupt from several different sets.  First, if
+	 * this link only has one valid IRQ, use that.  Second, we
+	 * check the set of PCI only interrupts from the $PIR.  Third,
+	 * we check the set of known-good interrupts that the BIOS has
+	 * already used.  Lastly, we check the "all possible valid
+	 * IRQs" set.
 	 */
 	if (!PCI_INTERRUPT_VALID(pci_link->pl_irq)) {
-		irq = pci_pir_choose_irq(pci_link,
-		    pci_route_table->pt_header.ph_pci_irqs);
+		if (pci_link->pl_irqmask != 0 && powerof2(pci_link->pl_irqmask))
+			irq = ffs(pci_link->pl_irqmask) - 1;
+		else
+			irq = pci_pir_choose_irq(pci_link,
+			    pci_route_table->pt_header.ph_pci_irqs);
 		if (!PCI_INTERRUPT_VALID(irq))
 			irq = pci_pir_choose_irq(pci_link, pir_bios_irqs);
 		if (!PCI_INTERRUPT_VALID(irq))
--- sys/dev/pci/pci.c.orig	2007-08-15 22:56:09.000000000 +0200
+++ sys/dev/pci/pci.c	2008-07-24 21:56:35.000000000 +0200
@@ -1898,7 +1898,9 @@
 	/* ATA devices needs special map treatment */
 	if ((pci_get_class(dev) == PCIC_STORAGE) &&
 	    (pci_get_subclass(dev) == PCIS_STORAGE_IDE) &&
-	    (pci_get_progif(dev) & PCIP_STORAGE_IDE_MASTERDEV))
+	    ((pci_get_progif(dev) & PCIP_STORAGE_IDE_MASTERDEV) ||
+	     (!pci_read_config(dev, PCIR_BAR(0), 4) &&
+	      !pci_read_config(dev, PCIR_BAR(2), 4))) )
 		pci_ata_maps(pcib, bus, dev, b, s, f, rl, force, prefetchmask);
 	else
 		for (i = 0; i < cfg->nummaps;)
